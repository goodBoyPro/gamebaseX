#include "guiFromImgui.h"
 guiFromImgui::guiFromImgui(const wchar_t *windowName) {
    // 建立配置文件所在文件夹
    createIfNoDir();
    // Create application window
    // ImGui_ImplWin32_EnableDpiAwareness();
  
    ::RegisterClassExW(&wc);
    // 主窗口是否透明
    bool isOpacity = true;
    if (!isOpacity) {
      hwnd = ::CreateWindowW(wc.lpszClassName, windowName, WS_OVERLAPPEDWINDOW,
                             100, 100, 1280, 800, nullptr, nullptr, wc.hInstance,
                             nullptr);
    } else {
      //WS_EX_TOPMOST | 
      hwnd = ::CreateWindowExW(WS_EX_LAYERED, wc.lpszClassName,
                               windowName, WS_POPUP, 100, 100, 1280, 800, nullptr,
                               nullptr, wc.hInstance, nullptr);
      
    }
  
    // Initialize Direct3D
    if (!CreateDeviceD3D(hwnd)) {
      CleanupDeviceD3D();
      ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
      printf("error:window created failed");
    }
  
    // Show the window
    ::ShowWindow(hwnd, SW_SHOWDEFAULT);
    ::UpdateWindow(hwnd);
  
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    (void)io;
    io.ConfigFlags |=
        ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
    io.ConfigFlags |=
        ImGuiConfigFlags_NavEnableGamepad; // Enable Gamepad Controls
  
    // ImGui::StyleColorsDark();
    ImGui::StyleColorsLight();
  
    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);
  
    ImFont *font =
        io.Fonts->AddFontFromFileTTF("res/font/heiti.ttf", 20.0f, nullptr,
                                     io.Fonts->GetGlyphRangesChineseFull());
    IM_ASSERT(font);
  }
  
 guiFromImgui &guiFromImgui::getUi() {
    static guiFromImgui ui;
    return ui;
  }
  
 guiFromImgui::~guiFromImgui() {
    // Cleanup
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();
  
    CleanupDeviceD3D();
    ::DestroyWindow(hwnd);
    ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
    for (auto [k, v] : allWindows) {
      delete v;
    }
  }
  
 void guiFromImgui::mainLoop() {
    // Main loop
    if (bOpen) {
      // Poll and handle messages (inputs, window resize, etc.)
      // See the WndProc() function below for our to dispatch events to the
      // Win32 backend.
      MSG msg;
      while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE)) {
        ::TranslateMessage(&msg);
        ::DispatchMessage(&msg);
        if (msg.message == WM_QUIT)
          close();
      }
  
      // Handle window being minimized or screen locked
      if (g_SwapChainOccluded &&
          g_pSwapChain->Present(0, DXGI_PRESENT_TEST) == DXGI_STATUS_OCCLUDED) {
        ::Sleep(10);
        return;
      }
      g_SwapChainOccluded = false;
  
      // Handle window resize (we don't resize directly in the WM_SIZE
      // handler)
      if (g_ResizeWidth != 0 && g_ResizeHeight != 0) {
        CleanupRenderTarget();
        g_pSwapChain->ResizeBuffers(0, g_ResizeWidth, g_ResizeHeight,
                                    DXGI_FORMAT_UNKNOWN, 0);
        g_ResizeWidth = g_ResizeHeight = 0;
        CreateRenderTarget();
      }
  
      // Start the Dear ImGui frame
      ImGui_ImplDX11_NewFrame();
      ImGui_ImplWin32_NewFrame();
      ImGui::NewFrame();
      ///////////////////////////////////////////////////
      // windows();
      for (auto &window : allWindows) {
        window.second->loop();
      }
      ///////////////////////////////////////////////////
      // Rendering
      ImGui::Render();
  
      g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView,
                                              nullptr);
      g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView,
                                                 clear_color_with_alpha);
  
      ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
  
      // Present
      HRESULT hr = g_pSwapChain->Present(1, 0); // Present with vsync
      // HRESULT hr = g_pSwapChain->Present(0, 0); // Present without vsync
      g_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);
    }
 }
 bool guiFromImgui::CreateDeviceD3D(HWND hWnd) {
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
  
    UINT createDeviceFlags = 0;
    // createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = {
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_0,
    };
    HRESULT res = D3D11CreateDeviceAndSwapChain(
        nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags,
        featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain,
        &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);
    if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software
                                       // driver if hardware is not available.
      res = D3D11CreateDeviceAndSwapChain(
          nullptr, D3D_DRIVER_TYPE_WARP, nullptr, createDeviceFlags,
          featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain,
          &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);
    if (res != S_OK)
      return false;
  
    CreateRenderTarget();
    return true;
  }
  
  void guiFromImgui::CleanupDeviceD3D() {
    CleanupRenderTarget();
    if (g_pSwapChain) {
      g_pSwapChain->Release();
      g_pSwapChain = nullptr;
    }
    if (g_pd3dDeviceContext) {
      g_pd3dDeviceContext->Release();
      g_pd3dDeviceContext = nullptr;
    }
    if (g_pd3dDevice) {
      g_pd3dDevice->Release();
      g_pd3dDevice = nullptr;
    }
  }
  
 void guiFromImgui::CreateRenderTarget() {
    ID3D11Texture2D *pBackBuffer;
    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr,
                                         &g_mainRenderTargetView);
    pBackBuffer->Release();
  }
  
 void guiFromImgui::CleanupRenderTarget() {
    if (g_mainRenderTargetView) {
      g_mainRenderTargetView->Release();
      g_mainRenderTargetView = nullptr;
    }
  }
  
  // Forward declare message handler from imgui_impl_win32.cpp
  extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd,
                                                               UINT msg,
                                                               WPARAM wParam,
                                                               LPARAM lParam);
  LRESULT WINAPI guiFromImgui::WndProc(HWND hWnd, UINT msg, WPARAM wParam,
                                              LPARAM lParam) {
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
      return true;
  
    switch (msg) {
    case WM_SIZE:
      if (wParam == SIZE_MINIMIZED)
        return 0;
      g_ResizeWidth = (UINT)LOWORD(lParam); // Queue resize
      g_ResizeHeight = (UINT)HIWORD(lParam);
      return 0;
    case WM_SYSCOMMAND:
      if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
        return 0;
      break;
    case WM_DESTROY:
      ::PostQuitMessage(0);
      return 0;
    }
    return ::DefWindowProcW(hWnd, msg, wParam, lParam);
  }
void guiFromImgui::createIfNoDir() {
    std::filesystem::path workingdir = std::filesystem::current_path();
    std::filesystem::path settingsDir = workingdir / "settings";
    if (std::filesystem::exists(settingsDir))
      return;
  
    std::filesystem::create_directory(settingsDir);
  }